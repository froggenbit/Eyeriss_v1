# This file is public domain, it can be freely copied without restrictions.
# SPDX-License-Identifier: CC0-1.0

import os
import random
import sys
from pathlib import Path
import numpy as np

import cocotb
from cocotb.clock import Clock
from cocotb.runner import get_runner
from cocotb.triggers import FallingEdge
from adder_model import pe_array_model


@cocotb.test()
async def pe_array_test(dut):
    clock = Clock(dut.clk, 1, units="ns")  # Create a 10us period clock on port clk
    cocotb.start_soon(clock.start())  # Start the clock
    await FallingEdge(dut.clk)  # Synchronize with the clock
    dut.rst_n.value = 0
    dut.enable.value = 0
    image = []
    image_for_model = np.zeros((64, 48, 1), dtype=int)
    for row in range(64):
        for col in range(48):
            value = (row * 48+ col+1) % 256  # 从 1 开始递增
            image.append(value)
            image_for_model[row,col,0] = value
    image_bits = 0
    for value in image:
        image_bits = (image_bits << 8) | value  # 将每个 8-bit 值拼接到一起
        # image_bits |= (value << (8 * len(image)))  # 每次将当前值放到高位
    dut.image.value = image_bits
    filter = []
    filter_for_model = np.zeros((3, 3, 1), dtype=int)
    for row in range(3):
        for col in range(3):
            value = (row * 3+ col+1)   # 从 1 开始递增
            filter.append(value)
            filter_for_model[row, col, 0] = value
    filter_bits = 0
    for value in filter:
        filter_bits = (filter_bits << 8) | value  # 将每个 8-bit 值拼接到一起
    dut.filter.value = filter_bits
    # conv model
    ref = pe_array_model(image_for_model, filter_for_model)
    for i in range(5):
        await FallingEdge(dut.clk)
    dut.rst_n.value = 1
    # await FallingEdge(dut.clk)
    dut.enable.value = 1
    for _ in range(2000):
        await FallingEdge(dut.clk)
    #     val = random.randint(0, 1)
    #     dut.d.value = val  # Assign the random value val to the input port d
    #     assert dut.q.value == val, f"output q was incorrect on the {i}th cycle"


# def test_top_runner():
#
#     hdl_toplevel_lang = os.getenv("HDL_TOPLEVEL_LANG", "verilog")
#     sim = os.getenv("SIM", "icarus")
#
#     proj_path = Path(__file__).resolve().parent
#     sys.path.append(str(proj_path / "model"))
#
#     verilog_sources = []
#     vhdl_sources = []
#
#     if hdl_toplevel_lang == "verilog":
#         verilog_sources = [proj_path / "top.v"]
#         verilog_sources.append(proj_path / "SNN.v")
#         verilog_sources.append(proj_path / "GATED_OR.v")
#         verilog_sources.append(proj_path / "PATTERN.sv")
#     else:
#         vhdl_sources = [proj_path / "dff.vhdl"]
#
#     # equivalent to setting the PYTHONPATH environment variable
#     sys.path.append(str(proj_path / "tests"))
#
#     runner = get_runner(sim)
#     runner.build(
#         verilog_sources=verilog_sources,
#         vhdl_sources=vhdl_sources,
#         hdl_toplevel="SNN_top",
#         always=True,
#     )
#
#     runner.test(hdl_toplevel="top", test_module="test_top,")
#
#
# if __name__ == "__main__":
#     test_top_runner()
